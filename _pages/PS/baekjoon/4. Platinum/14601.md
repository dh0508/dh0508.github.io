---
title: "[BOJ Python] 14601번: 샤워실 바닥 깔기 (Large)"
tags:
    - Python
    - 구현
    - 분할 정복
    - 재귀
date: "2025-10-29"
thumbnail: "/assets/img/thumbnail/baekjoon.png"
---

# 문제  
> [문제 링크](https://www.acmicpc.net/problem/14601)  
<span style="display: inline-flex; align-items: center;">
  <img src="/img/tier/platinum5.png" alt="Platinum V" style="height:1em; width:auto; margin-right:4px;">
  <span style="color:#29D998; font-weight:bold;">플레티넘 V</span>
</span>

## 내용
오늘은 민규가 훈련소에 입소하는 날이다. 모든 행사를 마치고 생활관으로 돌아와서 쉬려는데 갑자기 교관이 들어오더니 민규의 이름을 부르는 것이 아닌가. 당황한 채로 따라갔더니 이번엔 김준서를 아느냐고 물어보았다. 그 녀석이 샤워실 바닥을 깔았는데, 배수구 위치까지 막아버렸다면서 같은 학교 출신인 민규가 다시 깔라는 것이었다.

어떻게 타일을 깔지 고민하던 민규는 샤워실의 구조가 정사각형이면서 한 변의 길이가 2의 제곱수라는 사실을 알아냈다. 준서는 여기까지만 고려해서 2x2 크기의 타일로 바닥을 전부 채운 것 같은데, 문제는 이렇게 하면 배수구가 있어야 할 위치를 비울 수가 없다는 것이다. 이런저런 방법을 생각하다가 4칸을 차지하는 정사각형 타일 대신 3칸을 차지하는 ㄱ자 모양의 타일을 사용하면 될 것 같다는 느낌을 받았다.

그런데 ㄱ자 타일을 어떻게 채워야 할까? 생각하다 지친 민규는 여러분에게 이 방법을 찾아달라고 부탁했다. 첫날부터 생활관에서 밤을 새우는 일이 없도록 여러분이 도와주자.

## 입력
첫 번째 줄에는 바닥의 한 변의 길이를 표현하는 자연수 K(1 ≤ K ≤ 7) 가 주어진다. 이때 바닥의 크기는 \(2^K\) 가 됨에 유의하라. 두 번째 줄에는 배수구의 위치를 나타내는 자연수 x, y (1 ≤ x, y ≤ \(2^K\))가 공백으로 분리돼서 주어진다. 이때 가장 왼쪽 아래가 (1, 1), 가장 오른쪽 위가 (\(2^K\), \(2^K\))이다.

## 출력
각 타일마다 고유한 번호를 매긴 타일의 배치도를 출력한다. 각 타일의 번호에는 19000 이하의 자연수만을 사용해야 한다. 배수구가 있는 위치는 -1로 표시한다. 가능한 답 중 하나만 출력하면 된다.

만약 알맞게 타일을 배치하는 방법이 존재하지 않는다면 -1을 출력한다.

# 풀이
2의 제곱수를 한 변으로 가지고 정사각형인 구조에 배수구의 위치를 피해 ㄱ자로 타일을 배치하는 문제이다.
트로미노 타일로도 유명한 이 문제는 분할 정복을 공부할 때 유명한 문제이다.

1. 보드를 4사분면으로 나눠 배수구가 있는 사분면을 찾는다.
2. 배수구가 없는 3개의 사분면에 속하도록 타일을 배치한다.
3. 그러면 4개의 사분면 모두가 배수구가 하나 있는(타일이 차있는) 구조가 되어 재귀적으로 반복한다.


## 정답 코드
> Python

```
import sys
def input():
    return sys.stdin.readline()

tile_num = 1

def tromino(board, size, top, left, hole_r, hole_c):
    global tile_num
    if size == 2:
        for r in range(2):
            for c in range(2):
                if (top + r, left + c) != (hole_r, hole_c):
                    board[top + r][left + c] = tile_num
        tile_num += 1
        return
    half = size // 2
    mid_r, mid_c = top + half, left + half
    if hole_r < mid_r and hole_c < mid_c:
        quad = 1
    elif hole_r < mid_r and hole_c >= mid_c:
        quad = 2
    elif hole_r >= mid_r and hole_c < mid_c:
        quad = 3
    else:
        quad = 4
    t = tile_num
    tile_num += 1
    if quad != 1: board[mid_r-1][mid_c-1] = t
    if quad != 2: board[mid_r-1][mid_c] = t
    if quad != 3: board[mid_r][mid_c-1] = t
    if quad != 4: board[mid_r][mid_c] = t
    if quad == 1:
        tromino(board, half, top, left, hole_r, hole_c)
    else:
        tromino(board, half, top, left, mid_r-1, mid_c-1)
    if quad == 2:
        tromino(board, half, top, mid_c, hole_r, hole_c)
    else:
        tromino(board, half, top, mid_c, mid_r-1, mid_c)
    if quad == 3:
        tromino(board, half, mid_r, left, hole_r, hole_c)
    else:
        tromino(board, half, mid_r, left, mid_r, mid_c-1)
    if quad == 4:
        tromino(board, half, mid_r, mid_c, hole_r, hole_c)
    else:
        tromino(board, half, mid_r, mid_c, mid_r, mid_c)

def solution(K, x, y):
    global tile_num
    size = 2 ** K
    board = [[0] * size for _ in range(size)]
    hole_r = size - y
    hole_c = x - 1
    board[hole_r][hole_c] = -1
    tile_num = 1
    tromino(board, size, 0, 0, hole_r, hole_c)
    return board

K = int(input())
x, y = map(int, input().split())
board = solution(K, x, y)
for row in board:
    print(' '.join(map(str, row)))

```