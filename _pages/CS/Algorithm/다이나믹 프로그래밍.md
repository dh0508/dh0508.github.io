---
title: "[Algorithm] 다이나믹 프로그래밍(Dynamic Programming)"
tags:
    - 다이나믹 프로그래밍
date: "2025-07-17"
thumbnail: "/assets/img/thumbnail/algorithm.png"
---

# 개요
다이나믹 프로그래밍, 동적 계획법, DP 모두 같은 말로 알고리즘 코딩테스트에 자주 등장하는 아이디어이다.
하나의 큰 문제를 여러 개의 작은 문제들로 나눠서 그 값들을 저장해가며 큰 문제를 해결해 중복 연산을 줄여주는 알고리즘이다.

주로 점화식만 찾으면 쉽게 해결된다.
풀이 순서는 "dp배열 생성" -> "처음 배열 수동으로 초기화" -> "점화식을 이용해 값 구하기" 로 진행한다. 

# 주로 사용되는 문제
최종적인 답을 위해 같은 연산이 계속해서 반복되는 문제에 주로 사용된다. 재귀로 풀 수 있지만 같은 연산이 계속될 때에 DP를 사용하면 유용하다.

대표적인 예제로 피보나치 수열이 있다.
## 피보나치 수열
피보나치 수열은 다음과 같이 정의되는 수열이다.
\\(F_0=0,\quad F_1=1,\quad F_{n+2}=F_{n+1}+F_n\\)
![](/img/algorithm/dp1.png)
몇 개 써보자면 다음과 같다.

|n|0|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|---|
|\\(F_n\\)​|0|1|1|2|3|5|8|13|21|34|55|

이 수열에서 \\(F_{10}\\)을 구하는 문제를 재귀와 다이나믹 프로그래밍으로 풀어보자.
### 1. 재귀
재귀를 이용하면
\\(F_{10}=F_9+F_8\\)
\\(=F_8+F_7+F_7+F_6\\)
\\(=F_7+F_6+F_6+F_5+F_6+F_5+F_5+F_4\\)
\\(+...=F_1+F_1+F_1+...\\) 이런 식으로 될 것이다.

이를 재귀로 모두 탐색하는 코드를 파이썬으로 짜보면 다음과 같다.
```
def func(n):  
    if n==0:  
        return 0  
    elif n==1:  
        return 1  
    else:  
        return func(n-1) + func(n-2)  
  
answer = func(10)
```
이 코드의 시간복잡도는 \\(O(2^n)\\)이다. n이 30만 되더라도 연산량이 약 10억이 된다.

### 2. 다이나믹 프로그래밍
다이나믹 프로그래밍을 이용하면 배열을 만들어서
\\([F_0=0, \quad F_1=1,\quad F_2=1,\quad F_3=2,\quad ...\quad F_{10}=55]\\)
이런 식으로 풀어나갈 것이다.

파이썬 코드로 짜보면 다음과 같다.
```
dp = [0 for _ in range(11)]
dp[0] = 0
dp[1] = 1

for i in range(2, 11):
    dp[i] = dp[i-1] + dp[i-2]

answer = dp[10]
```
이 코드의 시간복잡도는 \\(O(n)\\)이다. 

### 결론
재귀로 n이 30일 때와 다이나믹 프로그래밍으로 n이 10억일 때의 연산시간이 비슷하다.
동일한 연산을 하지 않아도 된다는 것은 생각보다 더 어마어마한 연산을 줄여준다.

# 문제에서

다이나믹 프로그래밍 문제에는 크게 두 개만 해결하면 문제없다. 
1. 이 문제가 dp로 해결하기에 좋은 문제인지 판단하기
2. 점화식 구하기


이 두 과정만 성공적으로 진행하면 거의 해결했다고 볼 수 있다. 1번은 여러 문제를 접하며 감을 잡는 것이 좋고, 2번은 쉬운 문제일 경우 직접 구할 수 있는 몇 개의 값을 구하고 규칙성을 찾으면 구할 수 있다. 그러나 어려운 문제일 경우 직접 구하기는 어렵고 2차원 dp배열을 요구하거나 수학적으로 접근해야 점화식을 구할 수 있을 것이다.